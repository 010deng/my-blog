{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{343:function(s,a,t){\"use strict\";t.r(a);var n=t(0),e=Object(n.a)({},(function(){var s=this,a=s.$createElement,t=s._self._c||a;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":s.$parent.slotKey}},[t(\"h1\",{attrs:{id:\"内存泄漏\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#内存泄漏\"}},[s._v(\"#\")]),s._v(\" 内存泄漏\")]),s._v(\" \"),t(\"p\",[s._v(\"在谈垃圾回收之前，想先引入一个概念 -- 内存泄漏 😄\")]),s._v(\" \"),t(\"blockquote\",[t(\"p\",[s._v(\"简单解释：不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。\")])]),s._v(\" \"),t(\"p\",[s._v(\"而在程序的运行中，我们需要及时释放掉未使用的内存，否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。\")]),s._v(\" \"),t(\"p\",[s._v(\"看到这里是不是觉得我在危言耸听，想着我开发web这么久，怎么就没发生过这么可怕的事呢？哈哈🤣，这其实是js帮我们自动完成了垃圾回收，不像C语言，还需要程序员们自己去分配内存，释放内存。\"),t(\"code\",[s._v(\"(malloc,free)\")])]),s._v(\" \"),t(\"blockquote\",[t(\"p\",[s._v('高级语言提供的自动内存管理，被称之为\"垃圾回收机制\"（garbage collector）。\\n当然js的垃圾回收机制并没有人们想象的那么智能，许多情况下也需要人们手动的去指定，下面我们开始谈一谈这神秘的垃圾回收机制')])]),s._v(\" \"),t(\"h1\",{attrs:{id:\"内存管理\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#内存管理\"}},[s._v(\"#\")]),s._v(\" 内存管理\")]),s._v(\" \"),t(\"blockquote\",[t(\"p\",[s._v(\"像C语言这样的底层语言一般都有底层的内存管理接口，比如 malloc()和free()。相反，JavaScript是在创建变量（对象，字符串等）时自动进行了分配内存，并且在不使用它们时“自动”释放。 释放的过程称为垃圾回收。这个“自动”是混乱的根源，并让JavaScript（和其他高级语言）开发者错误的感觉他们可以不关心内存管理。 --- MDN\")])]),s._v(\" \"),t(\"p\",[s._v(\"一般的内存管理，我们可以大致的将其分为三个部分：\")]),s._v(\" \"),t(\"ul\",[t(\"li\",[s._v(\"分配内存\")]),s._v(\" \"),t(\"li\",[s._v(\"使用内存\")]),s._v(\" \"),t(\"li\",[s._v(\"释放内存\")])]),s._v(\" \"),t(\"p\",[s._v(\"使用内存自不必多说，这个在大多数语言中都保持着极高的一致性。而分配内存，在js中的表现为创建一个变量并进行初始化，这意味着内存分配也是自动进行的。如如下代码，都是定义时自动分配内存\")]),s._v(\" \"),t(\"div\",{staticClass:\"language-js line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-js\"}},[t(\"code\",[t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"var\")]),s._v(\" n \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[s._v(\"=\")]),s._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token number\"}},[s._v(\"123\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\";\")]),s._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"// 给数值变量分配内存\")]),s._v(\"\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"var\")]),s._v(\" s \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[s._v(\"=\")]),s._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token string\"}},[s._v('\"azerty\"')]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\";\")]),s._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"// 给字符串分配内存\")]),s._v(\"\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"var\")]),s._v(\" d \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[s._v(\"=\")]),s._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"new\")]),s._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[s._v(\"Date\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"(\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\")\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\";\")]),s._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"// 分配一个 Date 对象\")]),s._v(\"\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"var\")]),s._v(\" e \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[s._v(\"=\")]),s._v(\" document\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\".\")]),t(\"span\",{pre:!0,attrs:{class:\"token function\"}},[s._v(\"createElement\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"(\")]),t(\"span\",{pre:!0,attrs:{class:\"token string\"}},[s._v(\"'div'\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\")\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\";\")]),s._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"// 分配一个 DOM 元素\")]),s._v(\"\\n\")])]),s._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),t(\"br\")])]),t(\"p\",[s._v(\"然而，内存管理真正的难度并不在于前两者，而是在于第三点，如何去判断内存是否不再需要。前面我们提到了，js有自动释放的功能，但实际情况中GC并没有那么智能，往往也需要我们去显示释放\"),t(\"code\",[s._v(\"arr = null\")]),s._v(\"，我们需要知道js垃圾回收的原理，才能更好的利用它的自动能力\")]),s._v(\" \"),t(\"h1\",{attrs:{id:\"垃圾回收\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#垃圾回收\"}},[s._v(\"#\")]),s._v(\" 垃圾回收\")]),s._v(\" \"),t(\"p\",[s._v(\"js的垃圾回收大致可以分为两种：引用计数型，标记-清除型\")]),s._v(\" \"),t(\"h2\",{attrs:{id:\"引用计数\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#引用计数\"}},[s._v(\"#\")]),s._v(\" 引用计数\")]),s._v(\" \"),t(\"p\",[s._v(\"在谈这个实现思路之前，我们还是得知道什么是引用：\")]),s._v(\" \"),t(\"blockquote\",[t(\"p\",[s._v(\"在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象\")])]),s._v(\" \"),t(\"p\",[s._v(\"而引用计数顾名思义，是去判断一个对象在环境中是否被其他对象所引用，当引用数为0时，将被清除\")]),s._v(\" \"),t(\"div\",{staticClass:\"language-js line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-js\"}},[t(\"code\",[t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"var\")]),s._v(\" o \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[s._v(\"=\")]),s._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"{\")]),s._v(\" \\n  a\"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[s._v(\":\")]),s._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"{\")]),s._v(\"\\n    b\"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[s._v(\":\")]),t(\"span\",{pre:!0,attrs:{class:\"token number\"}},[s._v(\"2\")]),s._v(\"\\n  \"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"}\")]),s._v(\"\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"}\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\";\")]),s._v(\" \\n\"),t(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o\")]),s._v(\"\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"// 很显然，没有一个可以被垃圾收集\")]),s._v(\"\\n\\n\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"var\")]),s._v(\" o2 \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[s._v(\"=\")]),s._v(\" o\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\";\")]),s._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"// o2变量是第二个对“这个对象”的引用\")]),s._v(\"\\n\\no \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[s._v(\"=\")]),s._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token number\"}},[s._v(\"1\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\";\")]),s._v(\"      \"),t(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"// 现在，“这个对象”只有一个o2变量的引用了，“这个对象”的原始引用o已经没有\")]),s._v(\"\\n\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"var\")]),s._v(\" oa \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[s._v(\"=\")]),s._v(\" o2\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\".\")]),s._v(\"a\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\";\")]),s._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"// 引用“这个对象”的a属性\")]),s._v(\"\\n               \"),t(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"// 现在，“这个对象”有两个引用了，一个是o2，一个是oa\")]),s._v(\"\\n\\no2 \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[s._v(\"=\")]),s._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token string\"}},[s._v('\"yo\"')]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\";\")]),s._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"// 虽然最初的对象现在已经是零引用了，可以被垃圾回收了\")]),s._v(\"\\n           \"),t(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"// 但是它的属性a的对象还在被oa引用，所以还不能回收\")]),s._v(\"\\n\\noa \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[s._v(\"=\")]),s._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"null\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\";\")]),s._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"// a属性的那个对象现在也是零引用了\")]),s._v(\"\\n           \"),t(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"// 它可以被垃圾回收了\")]),s._v(\"\\n\")])]),s._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"6\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"7\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"8\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"9\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"10\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"11\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"12\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"13\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"14\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"15\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"16\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"17\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"18\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"19\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"20\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"21\")]),t(\"br\")])]),t(\"p\",[s._v(\"这种算法的设计思路非常简单，可惜的是，它无法将循环引用的对象清除\")]),s._v(\" \"),t(\"div\",{staticClass:\"language-js line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-js\"}},[t(\"code\",[t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"function\")]),s._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token function\"}},[s._v(\"f\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"(\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\")\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"{\")]),s._v(\"\\n  \"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"var\")]),s._v(\" o \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[s._v(\"=\")]),s._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"{\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"}\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\";\")]),s._v(\"\\n  \"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"var\")]),s._v(\" o2 \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[s._v(\"=\")]),s._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"{\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"}\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\";\")]),s._v(\"\\n  o\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\".\")]),s._v(\"a \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[s._v(\"=\")]),s._v(\" o2\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\";\")]),s._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"// o 引用 o2\")]),s._v(\"\\n  o2\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\".\")]),s._v(\"a \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[s._v(\"=\")]),s._v(\" o\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\";\")]),s._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"// o2 引用 o\")]),s._v(\"\\n\\n  \"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"return\")]),s._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token string\"}},[s._v('\"azerty\"')]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\";\")]),s._v(\"\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"}\")]),s._v(\"\\n\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token function\"}},[s._v(\"f\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"(\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\")\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\";\")]),s._v(\"\\n\")])]),s._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"6\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"7\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"8\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"9\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"10\")]),t(\"br\")])]),t(\"p\",[s._v(\"只要存在引用，它就不会被GC，即使在后面已经用不着了\")]),s._v(\" \"),t(\"h2\",{attrs:{id:\"标记-清除\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#标记-清除\"}},[s._v(\"#\")]),s._v(\" 标记-清除\")]),s._v(\" \"),t(\"p\",[s._v(\"这个算法的提出可以说是比较好的解决了循环引用的问题，它不再是以是否被引用来判断一个对象是否要被回收，而是设立一个全局对象，从全局对象上去获取变量，再从获取到的变量继续往下获取。通过是否能获取到一个对象，去判断这个对象是否应该被回收。因为循环引用中的变量无法被全局对象获取到，所以就可以很自然的将其清除\")]),s._v(\" \"),t(\"h1\",{attrs:{id:\"扩展\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#扩展\"}},[s._v(\"#\")]),s._v(\" 扩展\")]),s._v(\" \"),t(\"p\",[s._v(\"上面主要说了垃圾回收的一些实现思路，这一节将说一说和垃圾回收相关的一些扩展。\")]),s._v(\" \"),t(\"h2\",{attrs:{id:\"闭包\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#闭包\"}},[s._v(\"#\")]),s._v(\" 闭包\")]),s._v(\" \"),t(\"p\",[s._v(\"作为前端程序员，相信大家都接触过闭包，我们知道闭包的主要作用是两个：访问外层变量和维持变量引用。通过前面垃圾回收的铺垫，相信大家也能理解到为什么闭包可以维持变量的引用，让浏览器不对它进行回收了吧\")]),s._v(\" \"),t(\"h2\",{attrs:{id:\"es6-weakmap-weakset\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#es6-weakmap-weakset\"}},[s._v(\"#\")]),s._v(\" ES6 WeakMap/WeakSet\")]),s._v(\" \"),t(\"p\",[s._v(\"有使用过ES6的朋友们，应该对这两个数据结构也挺熟悉的，他们表示弱引用，也就是说存放在这两个数据结构中并不会计入引用次数中。\")]),s._v(\" \"),t(\"div\",{staticClass:\"language-js line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-js\"}},[t(\"code\",[t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"const\")]),s._v(\" wm \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[s._v(\"=\")]),s._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"new\")]),s._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[s._v(\"WeakMap\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"(\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\")\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\";\")]),s._v(\"\\n\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"const\")]),s._v(\" element \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[s._v(\"=\")]),s._v(\" document\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\".\")]),t(\"span\",{pre:!0,attrs:{class:\"token function\"}},[s._v(\"getElementById\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"(\")]),t(\"span\",{pre:!0,attrs:{class:\"token string\"}},[s._v(\"'example'\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\")\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\";\")]),s._v(\"\\n\\nwm\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\".\")]),t(\"span\",{pre:!0,attrs:{class:\"token function\"}},[s._v(\"set\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"(\")]),s._v(\"element\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\",\")]),s._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token string\"}},[s._v(\"'some information'\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\")\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\";\")]),s._v(\"\\nwm\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\".\")]),t(\"span\",{pre:!0,attrs:{class:\"token function\"}},[s._v(\"get\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"(\")]),s._v(\"element\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\")\")]),s._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v('// \"some information')]),s._v(\"\\n\")])]),s._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"6\")]),t(\"br\")])]),t(\"p\",[s._v(\"这里element被引用次数看起来是2，其实是1哦，这就很好的解释了什么是弱引用\")]),s._v(\" \"),t(\"p\",[s._v(\"这俩数据结构往往用来声明一些想要用完马上清除的对象\")]),s._v(\" \"),t(\"h2\",{attrs:{id:\"v8对gc的升级\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#v8对gc的升级\"}},[s._v(\"#\")]),s._v(\" V8对GC的升级\")]),s._v(\" \"),t(\"p\",[s._v(\"V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。\")]),s._v(\" \"),t(\"h3\",{attrs:{id:\"新生代算法\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#新生代算法\"}},[s._v(\"#\")]),s._v(\" 新生代算法\")]),s._v(\" \"),t(\"p\",[s._v(\"新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。\")]),s._v(\" \"),t(\"p\",[s._v(\"在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。\")]),s._v(\" \"),t(\"h3\",{attrs:{id:\"老生代算法\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#老生代算法\"}},[s._v(\"#\")]),s._v(\" 老生代算法\")]),s._v(\" \"),t(\"p\",[s._v(\"老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。\")]),s._v(\" \"),t(\"p\",[s._v(\"在讲算法前，先来说下什么情况下对象会出现在老生代空间中：\")]),s._v(\" \"),t(\"ul\",[t(\"li\",[s._v(\"新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。\")]),s._v(\" \"),t(\"li\",[s._v(\"To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。\\n老生代中的空间很复杂，有如下几个空间\")])]),s._v(\" \"),t(\"div\",{staticClass:\"language-c line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-c\"}},[t(\"code\",[t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"enum\")]),s._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[s._v(\"AllocationSpace\")]),s._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"{\")]),s._v(\"\\n  \"),t(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"// TODO(v8:7464): Actually map this space's memory as read-only.\")]),s._v(\"\\n  RO_SPACE\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\",\")]),s._v(\"    \"),t(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"// 不变的对象空间\")]),s._v(\"\\n  NEW_SPACE\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\",\")]),s._v(\"   \"),t(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"// 新生代用于 GC 复制算法的空间\")]),s._v(\"\\n  OLD_SPACE\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\",\")]),s._v(\"   \"),t(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"// 老生代常驻对象空间\")]),s._v(\"\\n  CODE_SPACE\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\",\")]),s._v(\"  \"),t(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"// 老生代代码对象空间\")]),s._v(\"\\n  MAP_SPACE\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\",\")]),s._v(\"   \"),t(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"// 老生代 map 对象\")]),s._v(\"\\n  LO_SPACE\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\",\")]),s._v(\"    \"),t(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"// 老生代大空间对象\")]),s._v(\"\\n  NEW_LO_SPACE\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\",\")]),s._v(\"  \"),t(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"// 新生代大空间对象\")]),s._v(\"\\n\\n  FIRST_SPACE \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[s._v(\"=\")]),s._v(\" RO_SPACE\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\",\")]),s._v(\"\\n  LAST_SPACE \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[s._v(\"=\")]),s._v(\" NEW_LO_SPACE\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\",\")]),s._v(\"\\n  FIRST_GROWABLE_PAGED_SPACE \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[s._v(\"=\")]),s._v(\" OLD_SPACE\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\",\")]),s._v(\"\\n  LAST_GROWABLE_PAGED_SPACE \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[s._v(\"=\")]),s._v(\" MAP_SPACE\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"}\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\";\")]),s._v(\"\\n\")])]),s._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"6\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"7\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"8\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"9\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"10\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"11\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"12\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"13\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"14\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"15\")]),t(\"br\")])]),t(\"p\",[s._v(\"在老生代中，以下情况会先启动标记清除算法：\")]),s._v(\" \"),t(\"ul\",[t(\"li\",[s._v(\"某一个空间没有分块的时候\")]),s._v(\" \"),t(\"li\",[s._v(\"空间中被对象超过一定限制\")]),s._v(\" \"),t(\"li\",[s._v(\"空间不能保证新生代中的对象移动到老生代中\")])]),s._v(\" \"),t(\"p\",[s._v(\"在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行.\")]),s._v(\" \"),t(\"p\",[s._v(\"清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象像一端移动，直到所有对象都移动完成然后清理掉不需要的内存。\")]),s._v(\" \"),t(\"blockquote\",[t(\"p\",[s._v(\"好了，写到这差不多我想讲的内容都说了，后续如果有新的见解，也会补充上来。\")])])])}),[],!1,null,null,null);a.default=e.exports}}]);","extractedComments":[]}