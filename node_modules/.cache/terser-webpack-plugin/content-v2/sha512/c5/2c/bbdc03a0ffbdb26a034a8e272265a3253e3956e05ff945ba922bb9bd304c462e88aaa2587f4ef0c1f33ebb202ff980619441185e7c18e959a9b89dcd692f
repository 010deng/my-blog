{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{347:function(v,_,t){\"use strict\";t.r(_);var e=t(0),a=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":v.$parent.slotKey}},[t(\"h2\",{attrs:{id:\"第一章\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#第一章\"}},[v._v(\"#\")]),v._v(\" 第一章\")]),v._v(\" \"),t(\"p\",[t(\"code\",[v._v(\"{a,b}\")]),v._v(\"横向匹配，表示可以有a到b个数\\n\"),t(\"code\",[v._v(\"[123]\")]),v._v(\"纵向匹配，表示可以是这里面的任意一个值\\n如果数值比较多的话，可以使用 - 表示范围\")]),v._v(\" \"),t(\"p\",[v._v(\"字符组也可以取反\"),t(\"code\",[v._v(\"[^123]\")]),v._v(\"来表示除了其中的字符外的其它字符\")]),v._v(\" \"),t(\"p\",[v._v(\"许多情况下，正则自带的匹配符小写表示一个字符组，大写则表示取反\\n所以延伸出来如果要匹配任意的字符\"),t(\"code\",[v._v(\"[\\\\d\\\\D]\")]),v._v(\"或是其他\")]),v._v(\" \"),t(\"p\",[v._v(\"在使用量词{a,b}的时候要注意贪婪匹配与惰性匹配，贪婪匹配表示尽可能多的去匹配结果。惰性与之相反，在量词后面加个\"),t(\"code\",[v._v(\"？\")]),v._v(\"来表示，当量词满足最低条件时就不再尝试了\")]),v._v(\" \"),t(\"h2\",{attrs:{id:\"第二章\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#第二章\"}},[v._v(\"#\")]),v._v(\" 第二章\")]),v._v(\" \"),t(\"blockquote\",[t(\"p\",[v._v(\"要牢记一个概念，就是位置是指字符之间的位置，并不包括字符\")])]),v._v(\" \"),t(\"ul\",[t(\"li\",[t(\"code\",[v._v(\"^ $\")]),v._v(\" 这都是两个十分熟悉的位置了\")]),v._v(\" \"),t(\"li\",[t(\"code\",[v._v(\"\\\\b\")]),v._v(\" 表示单词边界 \"),t(\"code\",[v._v(\"\\\\w与\\\\W\")]),v._v(\" \"),t(\"code\",[v._v(\"\\\\w与^|$\")]),v._v(\" 之间的位置\")]),v._v(\" \"),t(\"li\",[t(\"code\",[v._v(\"\\\\B\")]),v._v(\" 则表示非单词边界\")])]),v._v(\" \"),t(\"p\",[v._v(\"还有一种位置\\n假设p是一种子匹配模式，\"),t(\"code\",[v._v(\"(?=p)\")]),v._v(\"表示p前面的那个位置\\n\"),t(\"code\",[v._v(\"(?!p)\")]),v._v(\"表示上面所表示位置的其他位置\")]),v._v(\" \"),t(\"p\",[v._v(\"一个好玩的案例：\\n不匹配任意字符：\"),t(\"code\",[v._v(\"/.^/\")]),v._v(\" (不存在的就达成目的了)\")]),v._v(\" \"),t(\"h2\",{attrs:{id:\"第三章\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#第三章\"}},[v._v(\"#\")]),v._v(\" 第三章\")]),v._v(\" \"),t(\"p\",[v._v(\"regexp中\"),t(\"strong\",[v._v(\"括号\")]),v._v(\"的作用主要体现在以下几点：\")]),v._v(\" \"),t(\"ol\",[t(\"li\",[t(\"p\",[v._v(\"分组 -- 可以提取数据，也可以让其作为一个整体去搭配其他运算符\\n使用match  或者regexp实例的$1,$2等\")])]),v._v(\" \"),t(\"li\",[t(\"p\",[v._v(\"嵌套括号的话是以左括号为标准看它来匹配整个分组的区域的\")])])]),v._v(\" \"),t(\"h2\",{attrs:{id:\"第四章\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#第四章\"}},[v._v(\"#\")]),v._v(\" 第四章\")]),v._v(\" \"),t(\"p\",[v._v(\"js正则匹配的原理 --回溯法\\n\"),t(\"strong\",[v._v(\"回溯法其实就是一直尝试的一个过程，一条路走不通就回退几步再不断尝试。\")])]),v._v(\" \"),t(\"p\",[v._v(\"而在js正则中产生回溯的情况有以下几种\")]),v._v(\" \"),t(\"ol\",[t(\"li\",[v._v(\"贪婪量词 --它总是会以最大的情况去匹配，不满足条件才往下砍\")]),v._v(\" \"),t(\"li\",[v._v(\"惰性量词 --它总是会以最小的情况去匹配，不满足条件才往上增\")]),v._v(\" \"),t(\"li\",[v._v(\"分支结构 --它是惰性的，意味着它满足前面的条件后就不会往后匹配了，但是如果前面不满足条件，走后面的分支也可以看成回溯\")])]),v._v(\" \"),t(\"h2\",{attrs:{id:\"第五章\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#第五章\"}},[v._v(\"#\")]),v._v(\" 第五章\")]),v._v(\" \"),t(\"p\",[v._v(\"这一章主要讲的是正则表达式中运算符的优先级问题\\n一般只需要了解括号的优先级较高，| 的优先级比较低就可以\")]),v._v(\" \"),t(\"blockquote\",[t(\"p\",[v._v(\"而第六、七章更多的偏向于实战，后序可能会补上相关的案例\")])])])}),[],!1,null,null,null);_.default=a.exports}}]);","extractedComments":[]}