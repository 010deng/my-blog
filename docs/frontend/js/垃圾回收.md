--- 
title: 浅析垃圾回收机制
date: 2020-04-03
categories: 
 - frontEnd
tags: 
 - GC
---

# 内存泄漏
在谈垃圾回收之前，想先引入一个概念 -- 内存泄漏 :smile:
> 简单解释：不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。

而在程序的运行中，我们需要及时释放掉未使用的内存，否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。

看到这里是不是觉得我在危言耸听，想着我开发web这么久，怎么就没发生过这么可怕的事呢？哈哈:rofl:，这其实是js帮我们自动完成了垃圾回收，不像C语言，还需要程序员们自己去分配内存，释放内存。`(malloc,free)`
> 高级语言提供的自动内存管理，被称之为"垃圾回收机制"（garbage collector）。
当然js的垃圾回收机制并没有人们想象的那么智能，许多情况下也需要人们手动的去指定，下面我们开始谈一谈这神秘的垃圾回收机制

# 内存管理
> 像C语言这样的底层语言一般都有底层的内存管理接口，比如 malloc()和free()。相反，JavaScript是在创建变量（对象，字符串等）时自动进行了分配内存，并且在不使用它们时“自动”释放。 释放的过程称为垃圾回收。这个“自动”是混乱的根源，并让JavaScript（和其他高级语言）开发者错误的感觉他们可以不关心内存管理。 --- MDN

一般的内存管理，我们可以大致的将其分为三个部分：
* 分配内存
* 使用内存
* 释放内存

使用内存自不必多说，这个在大多数语言中都保持着极高的一致性。而分配内存，在js中的表现为创建一个变量并进行初始化，这意味着内存分配也是自动进行的。如如下代码，都是定义时自动分配内存
```js
var n = 123; // 给数值变量分配内存
var s = "azerty"; // 给字符串分配内存
var d = new Date(); // 分配一个 Date 对象
var e = document.createElement('div'); // 分配一个 DOM 元素
```
然而，内存管理真正的难度并不在于前两者，而是在于第三点，如何去判断内存是否不再需要。前面我们提到了，js有自动释放的功能，但实际情况中GC并没有那么智能，往往也需要我们去显示释放`arr = null`，我们需要知道js垃圾回收的原理，才能更好的利用它的自动能力

# 垃圾回收
js的垃圾回收大致可以分为两种：引用计数型，标记-清除型

## 引用计数
在谈这个实现思路之前，我们还是得知道什么是引用：
> 在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象

而引用计数顾名思义，是去判断一个对象在环境中是否被其他对象所引用，当引用数为0时，将被清除

```js
var o = { 
  a: {
    b:2
  }
}; 
// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o
// 很显然，没有一个可以被垃圾收集


var o2 = o; // o2变量是第二个对“这个对象”的引用

o = 1;      // 现在，“这个对象”只有一个o2变量的引用了，“这个对象”的原始引用o已经没有

var oa = o2.a; // 引用“这个对象”的a属性
               // 现在，“这个对象”有两个引用了，一个是o2，一个是oa

o2 = "yo"; // 虽然最初的对象现在已经是零引用了，可以被垃圾回收了
           // 但是它的属性a的对象还在被oa引用，所以还不能回收

oa = null; // a属性的那个对象现在也是零引用了
           // 它可以被垃圾回收了
```

这种算法的设计思路非常简单，可惜的是，它无法将循环引用的对象清除

```js
function f(){
  var o = {};
  var o2 = {};
  o.a = o2; // o 引用 o2
  o2.a = o; // o2 引用 o

  return "azerty";
}

f();
```
只要存在引用，它就不会被GC，即使在后面已经用不着了

## 标记-清除
这个算法的提出可以说是比较好的解决了循环引用的问题，它不再是以是否被引用来判断一个对象是否要被回收，而是设立一个全局对象，从全局对象上去获取变量，再从获取到的变量继续往下获取。通过是否能获取到一个对象，去判断这个对象是否应该被回收。因为循环引用中的变量无法被全局对象获取到，所以就可以很自然的将其清除

# 扩展
上面主要说了垃圾回收的一些实现思路，这一节将说一说和垃圾回收相关的一些扩展。

## 闭包
作为前端程序员，相信大家都接触过闭包，我们知道闭包的主要作用是两个：访问外层变量和维持变量引用。通过前面垃圾回收的铺垫，相信大家也能理解到为什么闭包可以维持变量的引用，让浏览器不对它进行回收了吧

## ES6 WeakMap/WeakSet
有使用过ES6的朋友们，应该对这两个数据结构也挺熟悉的，他们表示弱引用，也就是说存放在这两个数据结构中并不会计入引用次数中。

```js
const wm = new WeakMap();

const element = document.getElementById('example');

wm.set(element, 'some information');
wm.get(element) // "some information
```
这里element被引用次数看起来是2，其实是1哦，这就很好的解释了什么是弱引用

这俩数据结构往往用来声明一些想要用完马上清除的对象

## V8对GC的升级
V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。

### 新生代算法
新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。

在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。

### 老生代算法
老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。

在讲算法前，先来说下什么情况下对象会出现在老生代空间中：

* 新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。
* To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。
老生代中的空间很复杂，有如下几个空间

```c
enum AllocationSpace {
  // TODO(v8:7464): Actually map this space's memory as read-only.
  RO_SPACE,    // 不变的对象空间
  NEW_SPACE,   // 新生代用于 GC 复制算法的空间
  OLD_SPACE,   // 老生代常驻对象空间
  CODE_SPACE,  // 老生代代码对象空间
  MAP_SPACE,   // 老生代 map 对象
  LO_SPACE,    // 老生代大空间对象
  NEW_LO_SPACE,  // 新生代大空间对象

  FIRST_SPACE = RO_SPACE,
  LAST_SPACE = NEW_LO_SPACE,
  FIRST_GROWABLE_PAGED_SPACE = OLD_SPACE,
  LAST_GROWABLE_PAGED_SPACE = MAP_SPACE
};
```
在老生代中，以下情况会先启动标记清除算法：

* 某一个空间没有分块的时候
* 空间中被对象超过一定限制
* 空间不能保证新生代中的对象移动到老生代中

在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行.

清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象像一端移动，直到所有对象都移动完成然后清理掉不需要的内存。

> 好了，写到这差不多我想讲的内容都说了，后续如果有新的见解，也会补充上来。





