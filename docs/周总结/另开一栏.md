--- 
title: 部分注意点汇总
date: 2020-03-01
categories: 
 - conclusion
tags: 
 - 总结
---

> 寒假学的东西太杂了，所以特此另开一栏进行记录


## 零散总结
* 正向代理隐藏真实客户端，反向代理隐藏真实服务端

* node的模块中如果同时存在exports和module.exports 将会忽略exports中的内容

* localstorage 存储的值读取出来都会是字符串类型，对象会输出"[object Object]"，数组没问题。另外在使用localstorage的时候，最好使用try-catch做一层包裹，防止因为用户关闭了本地存储功能而导致的代码阻塞

* 纯前端实现post的跨域，可以使用form的action属性，浏览器的同源策略并没有限制表单

* HTML5的部分规范中要求，`table > tbody > tr...，ul > li...`，这种情况，如果将组件直接写在`table`或者其他有固定层级关系的标签中，Vue可能会直接将组件渲染在外部标签之外。这时候就需要is来指定特定标签的值为组件
如：`<tr is='row'></tr>`
`Vue.component('row',{})`

* 具名插槽以及作用域插槽现在都用v-slot来代替，值得注意的是，v-slot只能作用在template上，另外一种比较优雅的方式是通过解构赋值来取得作用域插槽。

* 在使用Vue的过渡效果的时候，如果要使用@keyframes动画，则需要挑选能在入场和出场中一直持续的钩子中调用，即enter-active，leave-active
那么由此可知，如果想使用animate.css这种基于keyframes的库的时候，就需要用到自定义名称了

* 一般情况下，Vue中的事件都绑定在单独的组件内部，不会对全局环境造成影响。但是一旦你使用了`Window.addEventListener`或者其他作用于全局的函数时，一定要在组件销毁逻辑或者`keep-alive`中的隐藏逻辑中对事件进行移出，否则这些事件将作用于全局环境，带来极大的问题


## commonJS 与 ESModule的区别
1. 前者基本用于服务端，是使用的同步导入，而后者基本使用在客户端，使用的是异步导入
2. 前者支持动态导入 如：require(${path}/xx.js) 这种形式
3. 前者是值拷贝，假设源导出文件发生改变，导入的数据并不会立即发生改变，需要重新导入来更新数据。而后者的数据变化基本上是实时的

## webpack加载器与插件的区别
加载器一般是用来对语言或者其他资源文件进行转义的，而插件则是用来改变构建过程的行为的

## 判断鼠标右键的事件
1. 阻止onTextmenu的默认行为，防止弹出浏览器默认的弹框
2. 判断onmousedown(e)中的e.button的值，0,1,2分别代表鼠标的左键滚轮和右键

## 数据结构相关

### 循环队列的特征：
拥有队首和队尾指针（front，rear），增加元素，队尾指针加一，注意考虑队列循环的特征（this.rear+1）%this.max，删除元素类似。
另外还需要知道指针指向的元素与实际队头队尾还有1的差距。

### 判断一个链表是否为循环链表：
可以设置两个指针（slow，fast）顾名思义，设置fast指针在slow指针的前面，如果将来某种情况，fast指针跑到slow指针后面了，则说明该链表为循环链表

### 树的递归遍历
树的遍历是以根节点所在的位置来取得，前序遍历就是根左右，中序左根右依次类推，利用递归来写，另外这三种遍历都可称为深度遍历

树的广度遍历可以利用队列的数据结构来做，基本思路是：
1. 将根节点入队
2. 取出队首，判断是否有左右节点，按照先左后右的方式入队
3. 循环这个过程，直到队列中的值为空

