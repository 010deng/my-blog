(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{348:function(t,e,a){"use strict";a.r(e);var v=a(0),s=Object(v.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("blockquote",[a("p",[t._v("寒假学的东西太杂了，所以特此另开一栏进行记录")])]),t._v(" "),a("h2",{attrs:{id:"零散总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#零散总结"}},[t._v("#")]),t._v(" 零散总结")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("正向代理隐藏真实客户端，反向代理隐藏真实服务端")])]),t._v(" "),a("li",[a("p",[t._v("node的模块中如果同时存在exports和module.exports 将会忽略exports中的内容")])]),t._v(" "),a("li",[a("p",[t._v('localstorage 存储的值读取出来都会是字符串类型，对象会输出"[object Object]"，数组没问题。另外在使用localstorage的时候，最好使用try-catch做一层包裹，防止因为用户关闭了本地存储功能而导致的代码阻塞')])]),t._v(" "),a("li",[a("p",[t._v("纯前端实现post的跨域，可以使用form的action属性，浏览器的同源策略并没有限制表单")])]),t._v(" "),a("li",[a("p",[t._v("HTML5的部分规范中要求，"),a("code",[t._v("table > tbody > tr...，ul > li...")]),t._v("，这种情况，如果将组件直接写在"),a("code",[t._v("table")]),t._v("或者其他有固定层级关系的标签中，Vue可能会直接将组件渲染在外部标签之外。这时候就需要is来指定特定标签的值为组件\n如："),a("code",[t._v("<tr is='row'></tr>")]),t._v(" "),a("code",[t._v("Vue.component('row',{})")])])]),t._v(" "),a("li",[a("p",[t._v("具名插槽以及作用域插槽现在都用v-slot来代替，值得注意的是，v-slot只能作用在template上，另外一种比较优雅的方式是通过解构赋值来取得作用域插槽。")])]),t._v(" "),a("li",[a("p",[t._v("在使用Vue的过渡效果的时候，如果要使用@keyframes动画，则需要挑选能在入场和出场中一直持续的钩子中调用，即enter-active，leave-active\n那么由此可知，如果想使用animate.css这种基于keyframes的库的时候，就需要用到自定义名称了")])]),t._v(" "),a("li",[a("p",[t._v("一般情况下，Vue中的事件都绑定在单独的组件内部，不会对全局环境造成影响。但是一旦你使用了"),a("code",[t._v("Window.addEventListener")]),t._v("或者其他作用于全局的函数时，一定要在组件销毁逻辑或者"),a("code",[t._v("keep-alive")]),t._v("中的隐藏逻辑中对事件进行移出，否则这些事件将作用于全局环境，带来极大的问题")])]),t._v(" "),a("li",[a("p",[t._v("git rebase 在多人协作的时候，commit线是一条，而 使用 git merge 的话，会有多条线按照正常思路合并。")])]),t._v(" "),a("li",[a("p",[t._v("src 是将指向的资源下载并应用到当前元素，会阻塞其他加载动作的执行，而href的加载动作是并行的")])]),t._v(" "),a("li",[a("p",[t._v("try-catch 如果还嵌套有回调函数在里面的话，将无法捕捉到回调函数中的错误，可以在回调函数中嵌套try-catch，或者全部改用async-await来处理")])]),t._v(" "),a("li",[a("p",[t._v("visibility:hidden 与 opacity:0 的区别在于，前者不会收到用户的操作（如点击事件等等），后者会对用户的交互进行响应")])]),t._v(" "),a("li",[a("p",[t._v("Cache-Control: no-cache,表示先缓存本地，但是在命中缓存之后必须与服务器验证缓存的新鲜度才能使用，并不是不缓存的意思")])]),t._v(" "),a("li",[a("p",[t._v("window.onload 是在整个页面加载的时候触发，包括图片，css，脚本文件等，而document.onload 是在DOM挂载完成的时候触发，在图像等加载之前")])]),t._v(" "),a("li",[a("p",[t._v("HTTP方法 put 和 post 的区别在于，put重复操作产生的效果是一样的（后一个同样的操作会覆盖掉前面的操作），而post不一样，会产生重复的数据。")])]),t._v(" "),a("li",[a("p",[t._v("SPA 路由之所以要利用 hash 片段，是因为片段的内容发生变化时，浏览器不会像 URI 发生变化时那样发起新的网络请求。这一点至关重要，因为 SPA 的整个大前提就是只请求页面或视图渲染所需要的数据，而不是为每一个页面获取并解析整份文档")])]),t._v(" "),a("li",[a("p",[t._v("数组的sort()，带函数和不带函数是有区别的，不带函数时，默认将数字转换成字符串再根据编码进行比较。")])])]),t._v(" "),a("h2",{attrs:{id:"commonjs-与-esmodule的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#commonjs-与-esmodule的区别"}},[t._v("#")]),t._v(" commonJS 与 ESModule的区别")]),t._v(" "),a("ol",[a("li",[t._v("前者基本用于服务端，是使用的同步导入，而后者基本使用在客户端，使用的是异步导入")]),t._v(" "),a("li",[t._v("前者支持动态导入 如：require(${path}/xx.js) 这种形式")]),t._v(" "),a("li",[t._v("前者是值拷贝，假设源导出文件发生改变，导入的数据并不会立即发生改变，需要重新导入来更新数据。而后者的数据变化基本上是实时的")])]),t._v(" "),a("h2",{attrs:{id:"webpack加载器与插件的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack加载器与插件的区别"}},[t._v("#")]),t._v(" webpack加载器与插件的区别")]),t._v(" "),a("p",[t._v("加载器一般是用来对语言或者其他资源文件进行转义的，而插件则是用来改变构建过程的行为的")]),t._v(" "),a("h2",{attrs:{id:"判断鼠标右键的事件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#判断鼠标右键的事件"}},[t._v("#")]),t._v(" 判断鼠标右键的事件")]),t._v(" "),a("ol",[a("li",[t._v("阻止onTextmenu的默认行为，防止弹出浏览器默认的弹框")]),t._v(" "),a("li",[t._v("判断onmousedown(e)中的e.button的值，0,1,2分别代表鼠标的左键滚轮和右键")])]),t._v(" "),a("h2",{attrs:{id:"express-和-koa-中间件的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#express-和-koa-中间件的区别"}},[t._v("#")]),t._v(" express 和 koa 中间件的区别")]),t._v(" "),a("ul",[a("li",[t._v("express是直线型中间件，程序穿过中间件的顺序和use的顺序有关")]),t._v(" "),a("li",[t._v("koa的中间件是洋葱模型，虽然起初调用的顺序也和use的顺序相关，但是程序穿出的过程是反过来的，就像是一圈一圈的洋葱一样，所以在调用时的顺序对程序的进行影响不大")])]),t._v(" "),a("h2",{attrs:{id:"为什么token能防止csrf攻击？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么token能防止csrf攻击？"}},[t._v("#")]),t._v(" 为什么Token能防止CSRF攻击？")]),t._v(" "),a("p",[t._v("我们知道CSRF的核心思想是获取用户的cookie，假借用户登录状态去实现一些操作。而这能够实现的一个基本要素在于，每一次用户的请求都会自动带上当前网页的cookie，而设置httponly固然能限制脚本获取cookie，但却无法从根本上阻止自动带上cookie的这个行为。之所以Token能够防止CSRF，很大程度在于他不会自动加在请求中，而且发出token的请求是程序员自己控制的。")]),t._v(" "),a("h2",{attrs:{id:"数据结构相关"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据结构相关"}},[t._v("#")]),t._v(" 数据结构相关")]),t._v(" "),a("h3",{attrs:{id:"循环队列的特征："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#循环队列的特征："}},[t._v("#")]),t._v(" 循环队列的特征：")]),t._v(" "),a("p",[t._v("拥有队首和队尾指针（front，rear），增加元素，队尾指针加一，注意考虑队列循环的特征（this.rear+1）%this.max，删除元素类似。\n另外还需要知道指针指向的元素与实际队头队尾还有1的差距。")]),t._v(" "),a("h3",{attrs:{id:"判断一个链表是否为循环链表："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#判断一个链表是否为循环链表："}},[t._v("#")]),t._v(" 判断一个链表是否为循环链表：")]),t._v(" "),a("p",[t._v("可以设置两个指针（slow，fast）顾名思义，设置fast指针在slow指针的前面，如果将来某种情况，fast指针跑到slow指针后面了，则说明该链表为循环链表")]),t._v(" "),a("h3",{attrs:{id:"树的递归遍历"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#树的递归遍历"}},[t._v("#")]),t._v(" 树的递归遍历")]),t._v(" "),a("p",[t._v("树的遍历是以根节点所在的位置来取得，前序遍历就是根左右，中序左根右依次类推，利用递归来写，另外这三种遍历都可称为深度遍历")]),t._v(" "),a("p",[t._v("树的广度遍历可以利用队列的数据结构来做，基本思路是：")]),t._v(" "),a("ol",[a("li",[t._v("将根节点入队")]),t._v(" "),a("li",[t._v("取出队首，判断是否有左右节点，按照先左后右的方式入队")]),t._v(" "),a("li",[t._v("循环这个过程，直到队列中的值为空")])]),t._v(" "),a("h3",{attrs:{id:"最值问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#最值问题"}},[t._v("#")]),t._v(" 最值问题")]),t._v(" "),a("p",[t._v("求最值的问题，往往可以考虑贪心算法，动态规划以及BFS")])])}),[],!1,null,null,null);e.default=s.exports}}]);